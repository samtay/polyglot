//! This question is asked by Google. You are given two strings, `s` and `t` which only consist of
//! lowercase letters. `t` is generated by shuffling the letters in `s` as well as potentially
//! adding an additional random character. Return the letter that was randomly added to `t` if it
//! exists, otherwise, return `' '`.
//!
//! Note: You may assume that at most one additional character can be added to t.

use std::collections::hash_map::Entry;
use std::collections::HashMap;

/// Iterate over t, building a hashmap of its character counts (deja vu). Iterate over s,
/// decrementing the hashmap counts; return the last remaining character in the hashmap if it
/// exists, else return a space char.
pub fn spot_diff(s: &str, t: &str) -> char {
    // Build character count of t
    let mut t_chars: HashMap<char, i16> = t.chars().fold(HashMap::new(), |mut cs, c| {
        cs.entry(c).and_modify(|n| *n += 1).or_insert(1);
        cs
    });

    // Decrement chars from s
    for c in s.chars() {
        match t_chars.entry(c) {
            Entry::Vacant(_) => panic!("Invalid input"),
            Entry::Occupied(e) if *e.get() == 1 => {
                e.remove();
            }
            entry => {
                entry.and_modify(|n| *n -= 1);
            }
        }
    }

    // Inspect what's left over
    *t_chars.iter().next().map(|(c, _)| c).unwrap_or(&' ')
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_spot_diff() {
        assert_eq!(spot_diff("foobar", "barfoot"), 't');
        assert_eq!(spot_diff("ide", "idea"), 'a');
        assert_eq!(spot_diff("coding", "ingcod"), ' ');
    }

    #[test]
    #[should_panic]
    fn test_spot_diff_bad_input() {
        assert_eq!(spot_diff("coding", "ingod"), 'g');
    }
}
